<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>Module riak_core_ring</title>
<link rel="stylesheet" type="text/css" href="stylesheet.css" title="EDoc">
</head>
<body bgcolor="white">
<div class="navbar"><a name="#navbar_top"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<hr>

<h1>Module riak_core_ring</h1>
<ul class="index"><li><a href="#description">Description</a></li><li><a href="#types">Data Types</a></li><li><a href="#index">Function Index</a></li><li><a href="#functions">Function Details</a></li></ul>riak_core_ring manages a riak node's local view of partition ownership.


<h2><a name="description">Description</a></h2>riak_core_ring manages a riak node's local view of partition ownership.
       The functions in this module revolve around use of the chstate record,
       which should be treated as opaque by other modules.  Riak nodes exchange
       instances of these records via gossip in order to converge on a common
       view of node/partition ownership.
<h2><a name="types">Data Types</a></h2>

<h3 class="typedecl"><a name="type-chstate">chstate()</a></h3>
<p><tt>chstate() = <a href="#type-riak_core_ring">riak_core_ring()</a></tt></p>


<h3 class="typedecl"><a name="type-member_status">member_status()</a></h3>
<p><tt>member_status() = valid | invalid | leaving | exiting</tt></p>


<h3 class="typedecl"><a name="type-pending_change">pending_change()</a></h3>
<p><tt>pending_change() = {Owner::node(), NextOwner::node(), awaiting | complete} | {undefined, undefined, undefined}</tt></p>


<h3 class="typedecl"><a name="type-riak_core_ring">riak_core_ring()</a></h3>
<p><tt>riak_core_ring() = #chstate_v2{nodename = undefined | node(), vclock = undefined | <a href="vclock.html#type-vclock">vclock:vclock()</a>, chring = undefined | <a href="chash.html#type-chash">chash:chash()</a>, meta = undefined | dict(), clustername = undefined | {node(), term()}, next = undefined | [{integer(), node(), node(), [module()], awaiting | complete}], members = undefined | [{node(), {<a href="#type-member_status">member_status()</a>, <a href="vclock.html#type-vclock">vclock:vclock()</a>, []}}], claimant = undefined | node(), seen = undefined | [{node(), <a href="vclock.html#type-vclock">vclock:vclock()</a>}], rvsn = undefined | <a href="vclock.html#type-vclock">vclock:vclock()</a>}</tt></p>


<h2><a name="index">Function Index</a></h2>
<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#active_members-1">active_members/1</a></td><td>Produce a list of all active (not marked as down) cluster members.</td></tr>
<tr><td valign="top"><a href="#add_member-3">add_member/3</a></td><td></td></tr>
<tr><td valign="top"><a href="#all_member_status-1">all_member_status/1</a></td><td>Returns the current membership status for all nodes in the cluster.</td></tr>
<tr><td valign="top"><a href="#all_members-1">all_members/1</a></td><td>Produce a list of all nodes that are members of the cluster.</td></tr>
<tr><td valign="top"><a href="#all_owners-1">all_owners/1</a></td><td>Provide all ownership information in the form of {Index,Node} pairs.</td></tr>
<tr><td valign="top"><a href="#all_preflists-2">all_preflists/2</a></td><td>Provide every preflist in the ring, truncated at N.</td></tr>
<tr><td valign="top"><a href="#check_tainted-2">check_tainted/2</a></td><td></td></tr>
<tr><td valign="top"><a href="#claimant-1">claimant/1</a></td><td>Return the current claimant.</td></tr>
<tr><td valign="top"><a href="#claiming_members-1">claiming_members/1</a></td><td>Return a list of all members of the cluster that are eligible to
       claim partitions.</td></tr>
<tr><td valign="top"><a href="#cluster_name-1">cluster_name/1</a></td><td>Returns the unique identifer for this cluster.</td></tr>
<tr><td valign="top"><a href="#diff_nodes-2">diff_nodes/2</a></td><td>For two rings, return the list of owners that have differing ownership.</td></tr>
<tr><td valign="top"><a href="#disowning_indices-2">disowning_indices/2</a></td><td>Return all indices that a node is scheduled to give to another.</td></tr>
<tr><td valign="top"><a href="#down_member-3">down_member/3</a></td><td></td></tr>
<tr><td valign="top"><a href="#down_members-1">down_members/1</a></td><td>Return a list of all members of the cluster that are marked as down.</td></tr>
<tr><td valign="top"><a href="#downgrade-2">downgrade/2</a></td><td>Downgrade the latest ring structure to a specified version.</td></tr>
<tr><td valign="top"><a href="#equal_rings-2">equal_rings/2</a></td><td></td></tr>
<tr><td valign="top"><a href="#exit_member-3">exit_member/3</a></td><td></td></tr>
<tr><td valign="top"><a href="#fresh-0">fresh/0</a></td><td>This is used only when this node is creating a brand new cluster.</td></tr>
<tr><td valign="top"><a href="#fresh-1">fresh/1</a></td><td>Equivalent to fresh/0 but allows specification of the local node name.</td></tr>
<tr><td valign="top"><a href="#fresh-2">fresh/2</a></td><td>Equivalent to fresh/1 but allows specification of the ring size.</td></tr>
<tr><td valign="top"><a href="#future_indices-2">future_indices/2</a></td><td>Return all partition indices that will be owned by a node after all
       pending ownership transfers have completed.</td></tr>
<tr><td valign="top"><a href="#get_buckets-1">get_buckets/1</a></td><td>return the names of all the custom buckets stored in the ring.</td></tr>
<tr><td valign="top"><a href="#get_member_meta-3">get_member_meta/3</a></td><td></td></tr>
<tr><td valign="top"><a href="#get_meta-2">get_meta/2</a></td><td>Return a value from the cluster metadata dict.</td></tr>
<tr><td valign="top"><a href="#handoff_complete-3">handoff_complete/3</a></td><td>Marks a pending transfer as completed.</td></tr>
<tr><td valign="top"><a href="#index_owner-2">index_owner/2</a></td><td>Return the node that owns the given index.</td></tr>
<tr><td valign="top"><a href="#indices-2">indices/2</a></td><td>Return all partition indices owned by a node.</td></tr>
<tr><td valign="top"><a href="#is_primary-2">is_primary/2</a></td><td>Determine if a given Index/Node <code>IdxNode</code> combination is a
       primary.</td></tr>
<tr><td valign="top"><a href="#leave_member-3">leave_member/3</a></td><td></td></tr>
<tr><td valign="top"><a href="#legacy_reconcile-2">legacy_reconcile/2</a></td><td>Incorporate another node's state into our view of the Riak world.</td></tr>
<tr><td valign="top"><a href="#legacy_ring-1">legacy_ring/1</a></td><td>Returns true if the given ring is a legacy ring.</td></tr>
<tr><td valign="top"><a href="#member_status-2">member_status/2</a></td><td>Returns the current membership status for a node in the cluster.</td></tr>
<tr><td valign="top"><a href="#my_indices-1">my_indices/1</a></td><td>Return all partition indices owned by the node executing this function.</td></tr>
<tr><td valign="top"><a href="#nearly_equal-2">nearly_equal/2</a></td><td>Verify that the two rings are identical expect that metadata can
       differ and RingB's vclock is allowed to be equal or a direct
       descendant of RingA's vclock.</td></tr>
<tr><td valign="top"><a href="#next_owner-2">next_owner/2</a></td><td>Return details for a pending partition ownership change.</td></tr>
<tr><td valign="top"><a href="#next_owner-3">next_owner/3</a></td><td>Return details for a pending partition ownership change.</td></tr>
<tr><td valign="top"><a href="#num_partitions-1">num_partitions/1</a></td><td>Return the number of partitions in this Riak ring.</td></tr>
<tr><td valign="top"><a href="#owner_node-1">owner_node/1</a></td><td>Return the node that is responsible for a given chstate.</td></tr>
<tr><td valign="top"><a href="#pending_changes-1">pending_changes/1</a></td><td>Returns a list of all pending ownership transfers.</td></tr>
<tr><td valign="top"><a href="#preflist-2">preflist/2</a></td><td>For a given object key, produce the ordered list of
       {partition,node} pairs that could be responsible for that object.</td></tr>
<tr><td valign="top"><a href="#pretty_print-2">pretty_print/2</a></td><td></td></tr>
<tr><td valign="top"><a href="#random_node-1">random_node/1</a></td><td>Return a randomly-chosen node from amongst the owners.</td></tr>
<tr><td valign="top"><a href="#random_other_active_node-1">random_other_active_node/1</a></td><td>Return a randomly-chosen active node other than this one.</td></tr>
<tr><td valign="top"><a href="#random_other_index-1">random_other_index/1</a></td><td>Return a partition index not owned by the node executing this function.</td></tr>
<tr><td valign="top"><a href="#random_other_index-2">random_other_index/2</a></td><td></td></tr>
<tr><td valign="top"><a href="#random_other_node-1">random_other_node/1</a></td><td>Return a randomly-chosen node from amongst the owners other than this one.</td></tr>
<tr><td valign="top"><a href="#ready_members-1">ready_members/1</a></td><td>Returns a list of members guaranteed safe for requests.</td></tr>
<tr><td valign="top"><a href="#reconcile-2">reconcile/2</a></td><td>Incorporate another node's state into our view of the Riak world.</td></tr>
<tr><td valign="top"><a href="#reconcile_names-2">reconcile_names/2</a></td><td></td></tr>
<tr><td valign="top"><a href="#remove_member-3">remove_member/3</a></td><td></td></tr>
<tr><td valign="top"><a href="#rename_node-3">rename_node/3</a></td><td> Rename OldNode to NewNode in a Riak ring.</td></tr>
<tr><td valign="top"><a href="#responsible_index-2">responsible_index/2</a></td><td>Determine the integer ring index responsible
       for a chash key.</td></tr>
<tr><td valign="top"><a href="#ring_changed-2">ring_changed/2</a></td><td></td></tr>
<tr><td valign="top"><a href="#ring_ready-0">ring_ready/0</a></td><td></td></tr>
<tr><td valign="top"><a href="#ring_ready-1">ring_ready/1</a></td><td>Returns true if all cluster members have seen the current ring.</td></tr>
<tr><td valign="top"><a href="#ring_ready_info-1">ring_ready_info/1</a></td><td></td></tr>
<tr><td valign="top"><a href="#set_cluster_name-2">set_cluster_name/2</a></td><td>Sets the unique identifer for this cluster.</td></tr>
<tr><td valign="top"><a href="#set_owner-2">set_owner/2</a></td><td>Set the node that is responsible for a given chstate.</td></tr>
<tr><td valign="top"><a href="#set_tainted-1">set_tainted/1</a></td><td></td></tr>
<tr><td valign="top"><a href="#transfer_node-3">transfer_node/3</a></td><td></td></tr>
<tr><td valign="top"><a href="#update_member_meta-5">update_member_meta/5</a></td><td>Set a key in the member metadata orddict.</td></tr>
<tr><td valign="top"><a href="#update_meta-3">update_meta/3</a></td><td>Set a key in the cluster metadata dict.</td></tr>
<tr><td valign="top"><a href="#upgrade-1">upgrade/1</a></td><td>Upgrade old ring structures to the latest format.</td></tr>
</table>

<h2><a name="functions">Function Details</a></h2>

<h3 class="function"><a name="active_members-1">active_members/1</a></h3>
<div class="spec">
<p><tt>active_members(Chstate_v2) -&gt; any()</tt></p>
</div><p>Produce a list of all active (not marked as down) cluster members</p>

<h3 class="function"><a name="add_member-3">add_member/3</a></h3>
<div class="spec">
<p><tt>add_member(PNode, State, Node) -&gt; any()</tt></p>
</div>

<h3 class="function"><a name="all_member_status-1">all_member_status/1</a></h3>
<div class="spec">
<p><tt>all_member_status(State::<a href="#type-chstate">chstate()</a>) -&gt; [{node(), <a href="#type-member_status">member_status()</a>}]</tt><br></p>
</div><p>Returns the current membership status for all nodes in the cluster.</p>

<h3 class="function"><a name="all_members-1">all_members/1</a></h3>
<div class="spec">
<p><tt>all_members(State::<a href="#type-chstate">chstate()</a>) -&gt; [Node::term()]</tt><br></p>
</div><p>Produce a list of all nodes that are members of the cluster</p>

<h3 class="function"><a name="all_owners-1">all_owners/1</a></h3>
<div class="spec">
<p><tt>all_owners(State::<a href="#type-chstate">chstate()</a>) -&gt; [{Index::integer(), Node::term()}]</tt><br></p>
</div><p>Provide all ownership information in the form of {Index,Node} pairs.</p>

<h3 class="function"><a name="all_preflists-2">all_preflists/2</a></h3>
<div class="spec">
<p><tt>all_preflists(State::<a href="#type-chstate">chstate()</a>, N::integer()) -&gt; [[{Index::integer(), Node::term()}]]</tt><br></p>
</div><p>Provide every preflist in the ring, truncated at N.</p>

<h3 class="function"><a name="check_tainted-2">check_tainted/2</a></h3>
<div class="spec">
<p><tt>check_tainted(Chstate, Msg) -&gt; any()</tt></p>
</div>

<h3 class="function"><a name="claimant-1">claimant/1</a></h3>
<div class="spec">
<p><tt>claimant(State::<a href="#type-chstate">chstate()</a>) -&gt; node()</tt><br></p>
</div><p>Return the current claimant.</p>

<h3 class="function"><a name="claiming_members-1">claiming_members/1</a></h3>
<div class="spec">
<p><tt>claiming_members(State::<a href="#type-chstate">chstate()</a>) -&gt; [Node::node()]</tt><br></p>
</div><p>Return a list of all members of the cluster that are eligible to
       claim partitions.</p>

<h3 class="function"><a name="cluster_name-1">cluster_name/1</a></h3>
<div class="spec">
<p><tt>cluster_name(State::<a href="#type-chstate">chstate()</a>) -&gt; term()</tt><br></p>
</div><p>Returns the unique identifer for this cluster.</p>

<h3 class="function"><a name="diff_nodes-2">diff_nodes/2</a></h3>
<div class="spec">
<p><tt>diff_nodes(State1::<a href="#type-chstate">chstate()</a>, State2::<a href="#type-chstate">chstate()</a>) -&gt; [node()]</tt><br></p>
</div><p>For two rings, return the list of owners that have differing ownership.</p>

<h3 class="function"><a name="disowning_indices-2">disowning_indices/2</a></h3>
<div class="spec">
<p><tt>disowning_indices(State, Node) -&gt; any()</tt></p>
</div><p>Return all indices that a node is scheduled to give to another.</p>

<h3 class="function"><a name="down_member-3">down_member/3</a></h3>
<div class="spec">
<p><tt>down_member(PNode, State, Node) -&gt; any()</tt></p>
</div>

<h3 class="function"><a name="down_members-1">down_members/1</a></h3>
<div class="spec">
<p><tt>down_members(State::<a href="#type-chstate">chstate()</a>) -&gt; [Node::node()]</tt><br></p>
</div><p>Return a list of all members of the cluster that are marked as down.</p>

<h3 class="function"><a name="downgrade-2">downgrade/2</a></h3>
<div class="spec">
<p><tt>downgrade(X1, Chstate_v2) -&gt; any()</tt></p>
</div><p>Downgrade the latest ring structure to a specified version.</p>

<h3 class="function"><a name="equal_rings-2">equal_rings/2</a></h3>
<div class="spec">
<p><tt>equal_rings(A::<a href="#type-chstate">chstate()</a>, B::<a href="#type-chstate">chstate()</a>) -&gt; boolean()</tt><br></p>
</div>

<h3 class="function"><a name="exit_member-3">exit_member/3</a></h3>
<div class="spec">
<p><tt>exit_member(PNode, State, Node) -&gt; any()</tt></p>
</div>

<h3 class="function"><a name="fresh-0">fresh/0</a></h3>
<div class="spec">
<p><tt>fresh() -&gt; <a href="#type-chstate">chstate()</a></tt><br></p>
</div><p>This is used only when this node is creating a brand new cluster.</p>

<h3 class="function"><a name="fresh-1">fresh/1</a></h3>
<div class="spec">
<p><tt>fresh(NodeName::term()) -&gt; <a href="#type-chstate">chstate()</a></tt><br></p>
</div><p>Equivalent to fresh/0 but allows specification of the local node name.
       Called by fresh/0, and otherwise only intended for testing purposes.</p>

<h3 class="function"><a name="fresh-2">fresh/2</a></h3>
<div class="spec">
<p><tt>fresh(RingSize::integer(), NodeName::term()) -&gt; <a href="#type-chstate">chstate()</a></tt><br></p>
</div><p>Equivalent to fresh/1 but allows specification of the ring size.
       Called by fresh/1, and otherwise only intended for testing purposes.</p>

<h3 class="function"><a name="future_indices-2">future_indices/2</a></h3>
<div class="spec">
<p><tt>future_indices(State::<a href="#type-chstate">chstate()</a>, Node::node()) -&gt; [integer()]</tt><br></p>
</div><p>Return all partition indices that will be owned by a node after all
       pending ownership transfers have completed.</p>

<h3 class="function"><a name="get_buckets-1">get_buckets/1</a></h3>
<div class="spec">
<p><tt>get_buckets(State::<a href="#type-chstate">chstate()</a>) -&gt; [term()]</tt><br></p>
</div><p>return the names of all the custom buckets stored in the ring.</p>

<h3 class="function"><a name="get_member_meta-3">get_member_meta/3</a></h3>
<div class="spec">
<p><tt>get_member_meta(State, Member, Key) -&gt; any()</tt></p>
</div>

<h3 class="function"><a name="get_meta-2">get_meta/2</a></h3>
<div class="spec">
<p><tt>get_meta(Key::term(), State::<a href="#type-chstate">chstate()</a>) -&gt; {ok, term()} | undefined</tt><br></p>
</div><p>Return a value from the cluster metadata dict</p>

<h3 class="function"><a name="handoff_complete-3">handoff_complete/3</a></h3>
<div class="spec">
<p><tt>handoff_complete(State::<a href="#type-chstate">chstate()</a>, Idx::integer(), Mod::module()) -&gt; <a href="#type-chstate">chstate()</a></tt><br></p>
</div><p>Marks a pending transfer as completed.</p>

<h3 class="function"><a name="index_owner-2">index_owner/2</a></h3>
<div class="spec">
<p><tt>index_owner(State::<a href="#type-chstate">chstate()</a>, Idx::integer()) -&gt; Node::term()</tt><br></p>
</div><p>Return the node that owns the given index.</p>

<h3 class="function"><a name="indices-2">indices/2</a></h3>
<div class="spec">
<p><tt>indices(State::<a href="#type-chstate">chstate()</a>, Node::node()) -&gt; [integer()]</tt><br></p>
</div><p>Return all partition indices owned by a node.</p>

<h3 class="function"><a name="is_primary-2">is_primary/2</a></h3>
<div class="spec">
<p><tt>is_primary(Ring::<a href="#type-chstate">chstate()</a>, IdxNode::{integer(), node()}) -&gt; boolean()</tt><br></p>
</div><p>Determine if a given Index/Node <code>IdxNode</code> combination is a
       primary.</p>

<h3 class="function"><a name="leave_member-3">leave_member/3</a></h3>
<div class="spec">
<p><tt>leave_member(PNode, State, Node) -&gt; any()</tt></p>
</div>

<h3 class="function"><a name="legacy_reconcile-2">legacy_reconcile/2</a></h3>
<div class="spec">
<p><tt>legacy_reconcile(ExternState, MyState) -&gt; any()</tt></p>
</div><p>Incorporate another node's state into our view of the Riak world.</p>

<h3 class="function"><a name="legacy_ring-1">legacy_ring/1</a></h3>
<div class="spec">
<p><tt>legacy_ring(Chstate) -&gt; any()</tt></p>
</div><p>Returns true if the given ring is a legacy ring.</p>

<h3 class="function"><a name="member_status-2">member_status/2</a></h3>
<div class="spec">
<p><tt>member_status(State::<a href="#type-chstate">chstate()</a>, Node::node()) -&gt; <a href="#type-member_status">member_status()</a></tt><br></p>
</div><p>Returns the current membership status for a node in the cluster.</p>

<h3 class="function"><a name="my_indices-1">my_indices/1</a></h3>
<div class="spec">
<p><tt>my_indices(State::<a href="#type-chstate">chstate()</a>) -&gt; [integer()]</tt><br></p>
</div><p>Return all partition indices owned by the node executing this function.</p>

<h3 class="function"><a name="nearly_equal-2">nearly_equal/2</a></h3>
<div class="spec">
<p><tt>nearly_equal(RingA, RingB) -&gt; any()</tt></p>
</div><p>Verify that the two rings are identical expect that metadata can
       differ and RingB's vclock is allowed to be equal or a direct
       descendant of RingA's vclock. This matches the changes that the
       fix-up logic may make to a ring.</p>

<h3 class="function"><a name="next_owner-2">next_owner/2</a></h3>
<div class="spec">
<p><tt>next_owner(State::<a href="#type-chstate">chstate()</a>, Idx::integer()) -&gt; <a href="#type-pending_change">pending_change()</a></tt><br></p>
</div><p>Return details for a pending partition ownership change.</p>

<h3 class="function"><a name="next_owner-3">next_owner/3</a></h3>
<div class="spec">
<p><tt>next_owner(State::<a href="#type-chstate">chstate()</a>, Idx::integer(), Mod::module()) -&gt; <a href="#type-pending_change">pending_change()</a></tt><br></p>
</div><p>Return details for a pending partition ownership change.</p>

<h3 class="function"><a name="num_partitions-1">num_partitions/1</a></h3>
<div class="spec">
<p><tt>num_partitions(State::<a href="#type-chstate">chstate()</a>) -&gt; integer()</tt><br></p>
</div><p>Return the number of partitions in this Riak ring.</p>

<h3 class="function"><a name="owner_node-1">owner_node/1</a></h3>
<div class="spec">
<p><tt>owner_node(State::<a href="#type-chstate">chstate()</a>) -&gt; Node::term()</tt><br></p>
</div><p>Return the node that is responsible for a given chstate.</p>

<h3 class="function"><a name="pending_changes-1">pending_changes/1</a></h3>
<div class="spec">
<p><tt>pending_changes(State) -&gt; any()</tt></p>
</div><p>Returns a list of all pending ownership transfers.</p>

<h3 class="function"><a name="preflist-2">preflist/2</a></h3>
<div class="spec">
<p><tt>preflist(Key::binary(), State::<a href="#type-chstate">chstate()</a>) -&gt; [{Index::integer(), Node::term()}]</tt><br></p>
</div><p>For a given object key, produce the ordered list of
       {partition,node} pairs that could be responsible for that object.</p>

<h3 class="function"><a name="pretty_print-2">pretty_print/2</a></h3>
<div class="spec">
<p><tt>pretty_print(Ring, Opts) -&gt; any()</tt></p>
</div>

<h3 class="function"><a name="random_node-1">random_node/1</a></h3>
<div class="spec">
<p><tt>random_node(State::<a href="#type-chstate">chstate()</a>) -&gt; Node::term()</tt><br></p>
</div><p>Return a randomly-chosen node from amongst the owners.</p>

<h3 class="function"><a name="random_other_active_node-1">random_other_active_node/1</a></h3>
<div class="spec">
<p><tt>random_other_active_node(State::<a href="#type-chstate">chstate()</a>) -&gt; Node::term() | no_node</tt><br></p>
</div><p>Return a randomly-chosen active node other than this one.</p>

<h3 class="function"><a name="random_other_index-1">random_other_index/1</a></h3>
<div class="spec">
<p><tt>random_other_index(State::<a href="#type-chstate">chstate()</a>) -&gt; integer()</tt><br></p>
</div><p>Return a partition index not owned by the node executing this function.
       If this node owns all partitions, return any index.</p>

<h3 class="function"><a name="random_other_index-2">random_other_index/2</a></h3>
<div class="spec">
<p><tt>random_other_index(State::<a href="#type-chstate">chstate()</a>, Exclude::[term()]) -&gt; integer() | no_indices</tt><br></p>
</div>

<h3 class="function"><a name="random_other_node-1">random_other_node/1</a></h3>
<div class="spec">
<p><tt>random_other_node(State::<a href="#type-chstate">chstate()</a>) -&gt; Node::term() | no_node</tt><br></p>
</div><p>Return a randomly-chosen node from amongst the owners other than this one.</p>

<h3 class="function"><a name="ready_members-1">ready_members/1</a></h3>
<div class="spec">
<p><tt>ready_members(Chstate_v2) -&gt; any()</tt></p>
</div><p>Returns a list of members guaranteed safe for requests</p>

<h3 class="function"><a name="reconcile-2">reconcile/2</a></h3>
<div class="spec">
<p><tt>reconcile(ExternState::<a href="#type-chstate">chstate()</a>, MyState::<a href="#type-chstate">chstate()</a>) -&gt; {no_change, <a href="#type-chstate">chstate()</a>} | {new_ring, <a href="#type-chstate">chstate()</a>}</tt><br></p>
</div><p>Incorporate another node's state into our view of the Riak world.</p>

<h3 class="function"><a name="reconcile_names-2">reconcile_names/2</a></h3>
<div class="spec">
<p><tt>reconcile_names(RingA, RingB) -&gt; any()</tt></p>
</div>

<h3 class="function"><a name="remove_member-3">remove_member/3</a></h3>
<div class="spec">
<p><tt>remove_member(PNode, State, Node) -&gt; any()</tt></p>
</div>

<h3 class="function"><a name="rename_node-3">rename_node/3</a></h3>
<div class="spec">
<p><tt>rename_node(State::<a href="#type-chstate">chstate()</a>, OldNode::atom(), NewNode::atom()) -&gt; <a href="#type-chstate">chstate()</a></tt><br></p>
</div><p> Rename OldNode to NewNode in a Riak ring.</p>

<h3 class="function"><a name="responsible_index-2">responsible_index/2</a></h3>
<div class="spec">
<p><tt>responsible_index(ChashKey::<a href="chash.html#type-index">chash:index()</a>, Chstate_v2::<a href="#type-chstate">chstate()</a>) -&gt; integer()</tt><br></p>
</div><p>Determine the integer ring index responsible
       for a chash key.</p>

<h3 class="function"><a name="ring_changed-2">ring_changed/2</a></h3>
<div class="spec">
<p><tt>ring_changed(Node, State) -&gt; any()</tt></p>
</div>

<h3 class="function"><a name="ring_ready-0">ring_ready/0</a></h3>
<div class="spec">
<p><tt>ring_ready() -&gt; any()</tt></p>
</div>

<h3 class="function"><a name="ring_ready-1">ring_ready/1</a></h3>
<div class="spec">
<p><tt>ring_ready(State::<a href="#type-chstate">chstate()</a>) -&gt; boolean()</tt><br></p>
</div><p>Returns true if all cluster members have seen the current ring.</p>

<h3 class="function"><a name="ring_ready_info-1">ring_ready_info/1</a></h3>
<div class="spec">
<p><tt>ring_ready_info(State0) -&gt; any()</tt></p>
</div>

<h3 class="function"><a name="set_cluster_name-2">set_cluster_name/2</a></h3>
<div class="spec">
<p><tt>set_cluster_name(State, Name) -&gt; any()</tt></p>
</div><p>Sets the unique identifer for this cluster.</p>

<h3 class="function"><a name="set_owner-2">set_owner/2</a></h3>
<div class="spec">
<p><tt>set_owner(State::<a href="#type-chstate">chstate()</a>, Node::node()) -&gt; <a href="#type-chstate">chstate()</a></tt><br></p>
</div><p>Set the node that is responsible for a given chstate.</p>

<h3 class="function"><a name="set_tainted-1">set_tainted/1</a></h3>
<div class="spec">
<p><tt>set_tainted(Ring) -&gt; any()</tt></p>
</div>

<h3 class="function"><a name="transfer_node-3">transfer_node/3</a></h3>
<div class="spec">
<p><tt>transfer_node(Idx::integer(), Node::term(), MyState::<a href="#type-chstate">chstate()</a>) -&gt; <a href="#type-chstate">chstate()</a></tt><br></p>
</div>

<h3 class="function"><a name="update_member_meta-5">update_member_meta/5</a></h3>
<div class="spec">
<p><tt>update_member_meta(Node, State, Member, Key, Val) -&gt; any()</tt></p>
</div><p>Set a key in the member metadata orddict</p>

<h3 class="function"><a name="update_meta-3">update_meta/3</a></h3>
<div class="spec">
<p><tt>update_meta(Key::term(), Val::term(), State::<a href="#type-chstate">chstate()</a>) -&gt; <a href="#type-chstate">chstate()</a></tt><br></p>
</div><p>Set a key in the cluster metadata dict</p>

<h3 class="function"><a name="upgrade-1">upgrade/1</a></h3>
<div class="spec">
<p><tt>upgrade(Old) -&gt; any()</tt></p>
</div><p>Upgrade old ring structures to the latest format.</p>
<hr>

<div class="navbar"><a name="#navbar_bottom"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<p><i>Generated by EDoc, Apr 25 2012, 15:41:39.</i></p>
</body>
</html>
